create sequence table_name_id_seq;

alter sequence table_name_id_seq owner to postgres;

create table if not exists data
(
    id          integer generated by default as identity,
    name        varchar(50) not null,
    description varchar(100)
    );

alter table data
    owner to postgres;

alter sequence table_name_id_seq owned by data.id;

create table if not exists data_change_log
(
    id             serial
    primary key,
    operation_type text,
    new_data       jsonb,
    changed_at     timestamp default CURRENT_TIMESTAMP,
    old_data       jsonb
);

alter table data_change_log
    owner to postgres;

create or replace function log_changes() returns trigger
    language plpgsql
as
$$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        INSERT INTO data_change_log (operation_type, old_data, new_data)
        VALUES (TG_OP, null, row_to_json(NEW));
RETURN NEW;
ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO public.data_change_log (operation_type, old_data, new_data)
        VALUES (TG_OP, row_to_json(OLD), row_to_json(NEW));
RETURN NEW;
ELSIF (TG_OP = 'DELETE') THEN
        INSERT INTO data_change_log (operation_type, old_data, new_data)
        VALUES (TG_OP, row_to_json(OLD), null);
RETURN OLD;
END IF;
END;
$$;

alter function log_changes() owner to postgres;

create trigger capture_insert
    after insert
    on data
    for each row
    execute procedure log_changes();

create trigger capture_update
    after update
    on data
    for each row
    execute procedure log_changes();

create trigger capture_delete
    after delete
    on data
    for each row
    execute procedure log_changes();

